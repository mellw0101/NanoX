NanoX, fork of nano.  TODO LIST.
1.  Change it so that when using CTRL+(UP/DOWN) it stops at indent diffs.

    NOTES:
        This is almost perfect and as i want to have it.  I implemented alot of 'rules' that makes coding
        better(at least for me) for example it stops at indent changes only when not empty line as well as
        stopping at start and end brackets for 'c/c++' I.E. '{', '}'.  As well as make it more friendly
        for coding as it puts the cursor in the correct indent when jumping into a bracket`ed area.
    STATUS:
        DONE!!!.
2.  Make 'prev_word' stop at eol if done from start of next line.  Also make it more intuative to use.

    NOTES:
        I dont know how i want this to behave yet so i will probebly change this.
    STATUS:
        KINDA DONE!!.
3.  Fix both next_word and prev_word so that cut_next_word and cut_prev_word works properly.
    
    NOTES:
        This mostly works like in 'vs-code' right now, I will need to conduct more test`s to find sinarios
        where it missbehaves, I have`t yet found any places where it directly missbehaves thoue it just need`s
        more rules to behave exactly the way I want in all case`s.
    STATUS:
        KINDA DONE!!.
4.  Make it so that when text is marked and '/" is pressed it 'text'/"text".
    
    NOTES:
        I also added so that '{', '[' and '(' puts closing brackets around marked region.
        I.E.  '{text}', '[text]' and '(text)'.  @see @file 'cpp.cpp' @func 'enclose_marked_region'. 
    STATUS:
        DONE!!.
5.  Make 'to_next_block' and 'to_prev_block' stop at '//' comments top and bottom.

    NOTES:
        It currently stops at top when going up and bottom when going down.
        I dont yet know if i want to change it.
    STATUS:
        ALMOST DONE!!!!.
6.  Implement a way to close and open brackets (will probebly be very HARD!!!).

    Notes:
        The main problem I`m having is that I can find and then not render the line`s I want when the
        key shortcut is pressed but i can`t just skip them(for now), because the line`s is a linked list.
        This makes it kinda hard to make them dissepare whithout weird side effects.  I will try to create
        a new way to render the lines before I continue with this, as I see no viable way to make more
        and more complex fetures when I have to change basicaly all the func`s that use the line`s just to
        avoid weird artifacts.  So if i can make a more selecteble rendering system, I will be able easily
        just not render the lines that should be 'hidden'.  Furthermore I have thought of other ways of
        doing this by for example, making a 'subfile' where the full text is and a second one that is
        'display`d' to the user, this way i can 'cut' the bracket out when it is supposed to be close`d
        then just add it in if it alrady is close`d when the shortcut is pressed.  Althoue this presents
        yet another issue, I will have to always keep track of both files witch will be alot easier to
        currupt or not save properly, what I mean by that is that this will make the user think they lost
        text if we crash before we sync the files.  This also adds alot of complexety witch will be hard
        to deal with down the line as it will need to be accaunted for when makeing or changing basicaly
        anything.
    FUNC`S OF INTREST:
        'edit_refresh'
        'draw_row'
    STATUS:
        NOT DONE.
7.  Implement live syntax.
    
    NOTES:
        I just need to make a system to save types and structs of function calls
        and such for help and error checking, also make the syntax highlighting of func
        params local to function only and not global.

        This has now been done and works very well.  The system i have created is very efficient at parsing words
        to highlight, the only this i need to fix before i make the system mush more complex is a way to make the
        applying of them to each line way faster and to make it way smarter in the sense that it remembers the
        entire file`s syntax so that it only updates when something changes instead of how it is now where only
        line`s in the edit window I.E. the line`s currently display`d to the user are 'saved', right now it rechecks
        all line`s that become visable every time the user scrolls making it unessesarely slow.  All this is needed
        to activate recursive header parsing when parsing headers again.  Because like I said my system is extreamly
        efficient and can parse 903840 lines/second.  The Problem is the constant need to recheck a masive amount of
        compiled regexes on every line that comes into view.  I think I will need to make it do the syntax once then
        not at all while moving as this would make the time it takes virtualy meningless as i will be able to offload
        to another thread if i want the text to appere instantly then the syntax when it is done.  If I also improve
        the time it takes to check a line by using more clever stuff to exclude more then check I will probebly be
        able to resolve this issue without changing the way the lines are rechecked, the problem is that i think the
        linked list of compiled regexes get exponatialy more shit as I have to go thrue a longer and longer list as
        I make it more complex with more syntax.

        The hard part is over it took quite a lot of time for me to figure out how to programeble add syntax to
        a system designed for .nanorc file parsing.  But I did eventualy figure it out, it took me working on this
        on and of for 3 weeks.  This is mostly because I had never worked with a linked list that has linked list`s
        nested before.  Anyway like I said the hard part is over now and I did create 'basic' live highlighting 
        in a few hour`s, that im not happy with at all but it is fast and works like it should.  The next step is to
        spend a couple of days and create a new system that I will be proud of.

        I have finaly successfully made parsing 4 times faster as well as being able to retrieve one 'char **' with all words
        in a file and the number of words in that array.  With this i have changed parsing for includes, but not yet for the main
        openfile as for now it is done line by line but i will make a new function that parses the entire file and see how fast
        I can make it.  Now i can also start to store data on struct`s, class`s and enum`s, and then start to apply the highlights
        only where thay should be for example a paramater for a function should only be highlighted inside that function.

        I finally fucking did it, i have implemented full live syntax with real time rendering.  This is way faster then the regex
        based system nano had before i have just done the first implementation for rendering comments and block comments.
        Here is some profiling data:
            render_comment:
                Mean = 9.69487e-05 ms,
                Stddev = 9.3153e-05 ms,
                Min = 3e-05 ms,
                Max = 0.00082 ms,
                Count = 23287.
        This is so much faster than any regex done before.  This is to check one line for for comments.
        I have also made colors way easier and faster and insted of compiling and adding one color tied to each word
        I would like to color, instead I have added some base colors instead and use them when i want saving time.
    STATUS:
        ALMOST DONE!!.
8.  Make 'ctrl+backspace' chop prev word, like most modern editors like 'vs-code'.

    NOTES:
        I had to add a check for term so i would know if currently running in xterm, as xterm uses unique codes.
        Atleast now i have added a global way to check the current env var 'term', it is init at the start of NanoX.
        I also kinda dont like the system in place to determen what keys where pressed as it makes codes that are
        destinct come out the same making me think that it was not possible to check if 'ctrl' was heal when pressing
        'backspace', as when debugging i would get the same code no matter what.  I finaly found out how the system
        retrives the raw hex codes from the term so i have now started to make checks here to determen what exact key
        is pressed.  I honestly find it weird why you would want a system where not all key`s and mod keys held, as
        this allows for total control as well as what i just created.  A way to delete prev word with 'ctrl+backspace',
        this is the norm in most other modern editors.
    STATUS:
        DONE!!.
9.  Make it possible to move one line up and down holding 'alt'.

    NOTES:
        This was quite easy to get to work, the harder(not really that hard) part was to make undoing and
        redoing work correctly.  After I worked that out it now works exactly the same as in 'vs-code'
        when moving one line up and down.  I`m very happy with how it works.  I just need to figure out
        how to make selected text stay selected after the line has been moved, after that it`s complete.
    STATUS:
        DONE!!.
10. Make it possible to move all selected lines up and down one line.

    NOTES:
        I can successfully do this now but I cannot manage to return the selection of the text once complete, I think
        this stems from the fact that I`m using my function to move one line to move the line above the selected text
        to the last line of the selection and vise versa.  This is a problem because I cannot currently keep the
        selection when just moving one line making it hard to understand why it wont just work if i save then restore
        the mark and current pos after we are done.  I think i need to make the this possible when moving just one line
        then this will be fixed, and if not I will have lerned how it works better.
    STATUS:
        NOT DONE.
11. Make auto bracket placement and proper indent if enter is pressed between '{}',
    LIKE THIS:
        {
            (cursor here)
        }
    INSTEAD OF THIS:
        {
        (cursor here)}

    NOTES:
        Was not that hard i just have to decide how i want the undo to work, in one go or two meaning
        undo the indent then separating or just return directly in one go.  I also added a check where
        it indents one if pressing enter when 'prev char' == '{' and 'next char' != '}'.
    STATUS:
        DONE!!.
12. Make doubles when typing '{', '(', '[', ' and ", also make this so if backspace is pressed directly
    after remove both char`s.

    NOTES:
        I added so that '<' so that creates a '>' if after #include.  This will be improved for edge case`s
        when found so it is not yet done.
    STATUS:
        ALMOST DONE!!.
13. Make '^Bsp' and '^Del' remove all spaces if more then one space to next/prev word, like 'vs-code'.

    NOTES:
        This was quite fun to be honest I remade the function 8 times and managed to make one of my begin_new_syntax
        func`s so far, IN MY OPINION.  I will probebly improve it even more when I find some edge case.
    STATUS:
        DONE!!.  FOR NOW.
14. Extend functionality of execute so you can do more when using '^E', for example run formater and such.

    STATUS:
        NOT DONE.
15. Create a system to find header file`s based on the file they are found in.
    
    NOTES:
        This will not be hard at all i think it will be easiest to just parse all files in the folder that the
        current file is in for local(") header files.  And for global(<) i will just parse the entire '/usr/include/'
        folder.
    STATUS:
        NOT DONE.
16. Multithreding just dropped bois!!!

    NOTES:
        Now this is amazing i coded this for 9 hours and it worked when i tested it ahhahahhaha!!
        i decided to make subthreads only as i dont se the benefit of having more threads for
        something other then data parsing and formating witch i can now completly do in the
        backround.  So the way i set it up is that there is a threadpool with a queue that has
        the threads all wating for a task to perform.  When I(the main thread) gives them
        a task that do that task in there thread and package it into a struct witch i make
        that has exactly the data that i want in the exact format i want making prossesing
        super fast.  i also ensured that for every iter of the main loop I read and prosses all
        callbacks that I recieved from the tasks that i sent.  This is done by making a linked
        list of callbacks that are 100 % thread safe as there is no shared data all of the 
        threads allocate the structs themselfs and then when i prosses them all i mutex
        lock the entire callback queue untill all callbacks are prossesed making race
        conditions imposible as there is only I on this side to access the data.
        I also made everything non blocking for all threads the only waiting thay will
        do is for the next task, I cannot wait to develop them further.
    
        This system is flawless.  there are newer problems, the only thing is that i built this before i
        figured out how the syntaxing worked and before i changed to my real-time system.  And then i really
        needed to run thing concurently because of the slowness of regexing and other things.  but as of now
        using my real-time system it`s so fast that Not even a single function i profile when i stress test takes more than
        '1' ms, to compleate and for all the real-time rendering functions.
        Well...
            render_bracket                : Mean = 0.000115283 ms, Stddev = 0.000442019 ms,    Min = 2e-05 ms,    Max = 0.01829 ms,  Count = 91626
            render_char_strings           : Mean = 6.34184e-05 ms, Stddev = 9.73154e-05 ms,    Min = 2e-05 ms,    Max = 0.01043 ms,  Count = 90696
            render_comment                : Mean = 7.71813e-05 ms, Stddev = 9.15774e-05 ms,    Min = 3e-05 ms,    Max = 0.00888 ms,  Count = 91626
            render_function_params        : Mean = 0.00133443 ms, Stddev = 0.00109268 ms,    Min = 0.00041 ms,    Max = 0.02217 ms,  Count = 91626
            render_preprossesor           : Mean = 3.70054e-05 ms, Stddev = 6.41127e-05 ms,    Min = 2e-05 ms,    Max = 0.00969 ms,  Count = 91626
            render_string_literals        : Mean = 5.2356e-05 ms, Stddev = 9.17636e-05 ms,    Min = 2e-05 ms,    Max = 0.00791 ms,  Count = 90696
            /* This one does all the rendering for each line.  And it never took more than '1' ms. for '91626' iters. */
            apply_syntax_to_line          : Mean = 0.00332462 ms, Stddev = 0.00518622 ms,    Min = 0.0007 ms,    Max = 0.979771 ms,  Count = 91626\
        
        I feel this becoming way easier, like all of it i dont know how to explain but i dont seem to make errors, even when i think that im gooing to make
        it crash non stop because of how i made a linked list, but no nothing.

        I will make NanoX better than vs code the next main problem is to add the ability to close and open brackets.
    STATUS:
        OBVIUSLY NOT DONE BUT NO ERRORS AT ALL!!
17. Create a rendering engine.

    NOTES:
        I have just created the first part of the rendering engine, the main function to render the text in a line.
        I will begin to split up the rendering into parts, this way i can start to multithread most actions.  By doing
        this I can make the visual updating imediet always.

        This is going well, and I have made real time rendering a thing now i just need to extend it further.

        Well i have made something amazing, truly.  I have been planning to do this for mounths, and when i finally
        cracked all the weird ways the OG. 'nano' integrated rcfile parsing systems for everything.  I could finaly do
        everything in real-time.  Here are some profiling results.
        
        Profiling report: [2024-09-03 11:04:42.297]
            apply_syntax_to_line          : Mean = 0.00332462 ms, Stddev = 0.00518622 ms,    Min = 0.0007 ms,    Max = 0.979771 ms,  Count = 91626
            check_include_file_syntax     : Mean = 0.31838 ms, Stddev = 0.211597 ms,    Min = 0.020611 ms,    Max = 0.49295 ms,  Count = 3
            display_string                : Mean = 8.41382e-05 ms, Stddev = 8.67018e-05 ms,    Min = 3e-05 ms,    Max = 0.01267 ms,  Count = 93675
            do_cpp_syntax                 : Mean = 0.312771 ms, Stddev = 0 ms,    Min = 0.312771 ms,    Max = 0.312771 ms,  Count = 1
            edit_refresh                  : Mean = 0.241847 ms, Stddev = 0.0656478 ms,    Min = 0.13139 ms,    Max = 1.75962 ms,  Count = 1985
            find_current_function         : Mean = 0.00270999 ms, Stddev = 0.00269315 ms,    Min = 6e-05 ms,    Max = 0.0181 ms,  Count = 1077
            flag_all_brackets             : Mean = 0.282631 ms, Stddev = 0 ms,    Min = 0.282631 ms,    Max = 0.282631 ms,  Count = 1
            line_word_list                : Mean = 0.000142748 ms, Stddev = 0.000170037 ms,    Min = 3e-05 ms,    Max = 0.01087 ms,  Count = 90696
            precalc_multicolorinfo        : Mean = 2.98019 ms, Stddev = 0 ms,    Min = 2.98019 ms,    Max = 2.98019 ms,  Count = 1
            render_bracket                : Mean = 0.000115283 ms, Stddev = 0.000442019 ms,    Min = 2e-05 ms,    Max = 0.01829 ms,  Count = 91626
            render_char_strings           : Mean = 6.34184e-05 ms, Stddev = 9.73154e-05 ms,    Min = 2e-05 ms,    Max = 0.01043 ms,  Count = 90696
            render_comment                : Mean = 7.71813e-05 ms, Stddev = 9.15774e-05 ms,    Min = 3e-05 ms,    Max = 0.00888 ms,  Count = 91626
            render_function_params        : Mean = 0.00133443 ms, Stddev = 0.00109268 ms,    Min = 0.00041 ms,    Max = 0.02217 ms,  Count = 91626
            render_preprossesor           : Mean = 3.70054e-05 ms, Stddev = 6.41127e-05 ms,    Min = 2e-05 ms,    Max = 0.00969 ms,  Count = 91626
            render_string_literals        : Mean = 5.2356e-05 ms, Stddev = 9.17636e-05 ms,    Min = 2e-05 ms,    Max = 0.00791 ms,  Count = 90696
            syntax_check_file             : Mean = 0.956221 ms, Stddev = 0 ms,    Min = 0.956221 ms,    Max = 0.956221 ms,  Count = 1
            update_line                   : Mean = 0.00469836 ms, Stddev = 0.00624281 ms,    Min = 0.00121 ms,    Max = 1.21486 ms,  Count = 91626
            words_from_file               : Mean = 0.166264 ms, Stddev = 0.107538 ms,    Min = 0.014421 ms,    Max = 0.24957 ms,  Count = 3

        As you can see, this is so fast and i have been able to add error highlighting as well, also in real time and i have just added to 
        'render_function_params' so that it can look at a type for a param and if the user tries to index into the param (i.e: param[index])
        it checks if the param is a '*' ptr and if not it gives an error directly in real time by making the var red. 
        
        At this time the renderer is almost 900 lines and nothing is slow.  Im happy, but also i have planed how i was gooing to do this
        as soon as i cracked all the subsystems and how thay worked and now i have.
    STATUS:
        NOT DONE.  But started and implemented.

NCURSES_HELP:
    'wattron' turns on an attribute for a 'WINDOW*'. 
NOTES:
    constexpr_atoi is slower then atoi.
    constexpr_tolower is faster then tolower.
    constexpr_strcasecmp is faster then strcasecmp.
OPTIMIZE:
    #pragma unroll 4.  Can be used to tell the compiler to unroll a loop.
    #pragma omp simd.  Can be used to tell the compiler to try to vectorize the loop. 

        